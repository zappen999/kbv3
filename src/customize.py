#!/usr/bin/env python3
import math
import os
import sys
from pprint import pprint
from geometry import LineSegment, \
    Point, \
    DDDPoint, \
    segments_distance, \
    deg2rad, \
    point_at_distance, \
    segments_intersect, \
    distance_between_points

from settings import FINGERS, \
        KEYCAP_BOX, \
        KEY_INTERSECTION_CLEARANCE, \
        SHOW_DEBUG_GEOMETRY, \
        KNUCKLE_WIDTH, \
        FINGER_SPREAD


KNUCKLE_DISTANCE = KNUCKLE_WIDTH / (len(FINGERS.items()) - 1)


def get_key_back_egde(p, angle):
    # back top of the key
    p0 = point_at_distance(p, KEYCAP_BOX['y']/2, angle-90)
    # above back top of the key
    p1 = point_at_distance(p0, -KEY_INTERSECTION_CLEARANCE, angle)
    # back bottom of the key
    p2 = point_at_distance(p1, (KEY_INTERSECTION_CLEARANCE*3)+KEYCAP_BOX['z'], angle)

    return LineSegment(p1, p2)


def get_key_front_egde(p, angle):
    # front top of the key
    p0 = point_at_distance(p, KEYCAP_BOX['y']/2, angle+90)
    # above front top of the key
    p1 = point_at_distance(p0, -KEY_INTERSECTION_CLEARANCE, angle)
    # below front bottom of the key
    p2 = point_at_distance(p1, (KEY_INTERSECTION_CLEARANCE*3)+KEYCAP_BOX['z'], angle)

    return LineSegment(p1, p2)


def generate_column_positions(finger):
    angles = [x/10 for x in range(finger['max_angle']*10, finger['min_angle']*10, 1)]
    p1 = Point(0, 0)  # knuckle (y, z)

    keys = []

    for angle in angles:
        p2 = point_at_distance(p1, finger['proximal_phalanx_length'], angle/3)
        p3 = point_at_distance(p2, finger['middle_phalanx_length'], angle/1.5)
        p4 = point_at_distance(p3, finger['distal_phalanx_length'], angle)

        if not len(keys):  # no keys, add first
            keys.append({
                'p1': p1,
                'p2': p2,
                'p3': p3,
                'p4': p4,
                'angle': angle
            })

            pprint({
                'angle': angle,
                'prev_p4': None,
                'p4': p4,
                'prev_key_egde': None,
                'this_key_egde': None,
                'key_egdes_distance': None,
            })
        else:
            prev_key = keys[-1]
            prev_key_egde = get_key_front_egde(prev_key['p4'], prev_key['angle'])
            this_key_egde = get_key_back_egde(p4, angle)

            pprint({
                'angle': angle,
                'prev_p4': prev_key['p4'],
                'p4': p4,
                'prev_key_egde': prev_key_egde,
                'this_key_egde': this_key_egde
            })

            clearance_segments_intersect = segments_intersect(this_key_egde, prev_key_egde)
            # Not the prettiest solution...
            is_far_apart_enough = distance_between_points(prev_key['p4'], p4) > KEYCAP_BOX['y']

            if is_far_apart_enough and not clearance_segments_intersect:
                keys.append({
                    'p1': p1,
                    'p2': p2,
                    'p3': p3,
                    'p4': p4,
                    'angle': angle,
                    'prev_key_egde': prev_key_egde,
                    'this_key_egde': this_key_egde,
                })

    return keys


def get_finger_position(index):
    """ Returns the position and rotation of the knuckle for a finger.
    """
    # TODO: Calculate the rotation of finger
    return DDDPoint(KNUCKLE_DISTANCE * index, 0, 0), 0


def export_openscad_settings(settings):
    f = os.path.join(os.path.dirname(__file__), 'settings.scad')

    with open(f, 'w') as f:
        f.write(settings)

def generate_openscad_settings():
    lines = []

    lines.append('// WARNING: This is autogenerated.')
    lines.append('// Edit settings.py and run customize.py to change these values')
    lines.append('FINGERS = [')

    finger_index = 0

    for name, params in reversed(FINGERS.items()):
        finger_keys = generate_column_positions(params)
        knuckle_position, knuckle_angle = get_finger_position(finger_index)

        lines.append("\t[")
        lines.append("\t\t[%s, %f]," % (
            knuckle_position.to_openscad(), knuckle_angle))
        lines.append("\t\t[")

        for finger_key in finger_keys:
            lines.append("\t\t\t[")
            lines.append("\t\t\t\t%s, %s, %s, %s, %f, %s, %s" % (
                finger_key['p1'].to_openscad(),
                finger_key['p2'].to_openscad(),
                finger_key['p3'].to_openscad(),
                finger_key['p4'].to_openscad(),
                finger_key['angle'],
                finger_key['prev_key_egde'].to_openscad() if 'prev_key_egde' in finger_key else 'false',
                finger_key['this_key_egde'].to_openscad() if 'this_key_egde' in finger_key else 'false'
            ))
            lines.append("\t\t\t],")

        lines.append("\t\t],")
        finger_index += 1

        lines.append("\t],")

    lines.append('];')
    lines.append('KEYCAP_BOX = [%f, %f, %f];' % (
        KEYCAP_BOX['x'], KEYCAP_BOX['y'], KEYCAP_BOX['z']))
    lines.append('SHOW_DEBUG_GEOMETRY = %s;' % (
        'true' if SHOW_DEBUG_GEOMETRY else 'false'))

    return '\n'.join(lines) + '\n'


settings = generate_openscad_settings()
export_openscad_settings(settings)
